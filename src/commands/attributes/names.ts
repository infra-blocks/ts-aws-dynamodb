import type { AttributePath } from "../../types.js";

/**
 * A path substitution always starts with the `#` character.
 */
export type PathSubstitution = `#${string}`;

// TODO: handle the ambiguous case where an attribute name contains a `.` character (and isn't a path). This might require adding vocabulary to operands.
// For example, it might be fixed by adding a `literal()` operand.
/**
 * Represents a set of attribute names used in a condition expression.
 *
 * The uses cases for using attribute names are:
 * - To access an attribute whose name conflicts with a DynamoDB reserved word.
 * - To create a placeholder for repeating occurrences of an attribute name in an expression.
 * - To prevent special characters in an attribute name from being misinterpreted in an expression.
 *
 * This class provides an automated way to generate attribute substitution variables
 * so that every attribute path in an expression can be treated the same: systematically replaced
 * with an automatically generated variable.
 *
 * The class keeps track of the variables generated for each attribute path, such that when
 * the user requests a substitution for a known value, that substitution is returned.
 *
 * When the user requests a substitution for an unknown attribute name, then one is generated and
 * stored for future use.
 */
export class AttributeNames {
  private readonly names: Map<AttributePath, PathSubstitution>;

  private constructor() {
    this.names = new Map<AttributePath, PathSubstitution>();
  }

  /**
   * Returns a substitution variable for the given attribute path.
   *
   * If the attribute path is seen for the first time by this object, a new substitution is generated,
   * assigned to the attribute path, and returned.
   *
   * If the attribute path was previously seen, then the associated substitution is returned.
   *
   * If the attribute path is a nested item expression, such as "object.inner.stuff", then the
   * function will treat it as 3 different paths by default. So 3 attribute names will
   * be generated: "object", "inner", "stuff", and the substitution returned will be of the
   * form "#attr1.#attr2.#attr3".
   *
   * @param attribute - The path of the attribute to substitute.
   *
   * @returns The substitution associated with the attribute path.
   */
  substitute(attribute: AttributePath): PathSubstitution {
    if (attribute.length === 0) {
      throw new Error(
        "error substituting attribute: empty attribute path not allowed",
      );
    }

    const pathTokens = attribute.split(".");
    const result = [];
    for (const token of pathTokens) {
      if (token.length === 0) {
        throw new Error(
          `error substituting attribute ${attribute}: empty path token not allowed`,
        );
      }

      // If it's indexed.
      const match = INDEX_REGEX.exec(token);
      if (match != null) {
        const indexedToken = token.slice(0, match.index);
        if (indexedToken.length === 0) {
          throw new Error(
            `error substituting attribute ${attribute}: empty path token not allowed`,
          );
        }

        // The substitute will be of the form #attrN[<originalIndex>]
        const pathSubstitute = this.getOrSetNextSubstituteFor(indexedToken);
        result.push(`${pathSubstitute}${match[1]}`);
        continue;
      }

      const substitute = this.getOrSetNextSubstituteFor(token);
      result.push(substitute);
    }
    return result.join(".") as PathSubstitution;
  }

  /**
   * Returns a record where the keys are the substitutions generated by this object
   * and the values are the corresponding attribute paths they where generated for.
   *
   * @returns A mapping of substitutions generated by this object, undefined if none were.
   */
  getSubstitutions(): Record<PathSubstitution, AttributePath> | undefined {
    if (this.names.size === 0) {
      return undefined;
    }

    const result: Record<PathSubstitution, AttributePath> = {};
    for (const [attribute, substitute] of this.names.entries()) {
      result[substitute] = attribute;
    }
    return result;
  }

  private getOrSetNextSubstituteFor(path: AttributePath): PathSubstitution {
    const current = this.names.get(path);
    if (current != null) {
      return current;
    }
    const next = `#attr${this.names.size + 1}` as PathSubstitution;
    this.names.set(path, next);
    return next;
  }

  static create(): AttributeNames {
    return new AttributeNames();
  }
}

const INDEX_REGEX = /(\[.*\].*)$/;
