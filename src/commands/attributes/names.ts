import type { AttributePath } from "../../types.js";

/**
 * A substitution always starts with the `#` character.
 */
export type Substitution = `#${string}`;

/**
 * Represents a set of attribute names used in a condition expression.
 *
 * The uses cases for using attribute names are:
 * - To access an attribute whose name conflicts with a DynamoDB reserved word.
 * - To create a placeholder for repeating occurrences of an attribute name in an expression.
 * - To prevent special characters in an attribute name from being misinterpreted in an expression.
 *
 * This class provides an automated way to generate attribute substitution variables
 * so that every attribute path in an expression can be treated the same: systematically replaced
 * with an automatically generated variable.
 *
 * The class keeps track of the variables generated for each attribute path, such that when
 * the user requests a substitution for a known value, that substitution is returned.
 *
 * When the user requests a substitution for an unknown attribute name, then one is generated and
 * stored for future use.
 */
export class AttributeNames {
  private readonly names: Map<AttributePath, Substitution>;

  private constructor() {
    this.names = new Map<AttributePath, Substitution>();
  }

  /**
   * Returns a substitution variable for the given attribute path.
   *
   * If the attribute path is seen for the first time by this object, a new substitution is generated,
   * assigned to the attribute path, and returned.
   *
   * If the attribute path was previously seen, then the associated substitution is returned.
   *
   * @param attribute - The path of the attribute to substitute.
   *
   * @returns The substitution associated with the attribute path.
   */
  substitute(attribute: AttributePath): Substitution {
    const current = this.names.get(attribute);
    if (current != null) {
      // If the attribute is already known, we return its current substitution.
      return current;
    }
    // Otherwise, we generate a new substitution for the attribute.
    const substitute = this.generateSubstitute(attribute);
    this.names.set(attribute, substitute);
    return substitute;
  }

  /**
   * Returns a record where the keys are the substitutions generated by this object
   * and the values are the corresponding attribute paths they where generated for.
   *
   * @returns A mapping of substitutions generated by this object, undefined if none were.
   */
  getSubstitutions(): Record<Substitution, AttributePath> | undefined {
    if (this.names.size === 0) {
      return undefined;
    }

    const result: Record<Substitution, AttributePath> = {};
    for (const [attribute, substitute] of this.names.entries()) {
      result[substitute] = attribute;
    }
    return result;
  }

  private generateSubstitute(attribute: AttributePath): Substitution {
    return `#${attribute}` as Substitution;
  }

  static create(): AttributeNames {
    return new AttributeNames();
  }
}
